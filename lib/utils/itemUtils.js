'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.rowItemsRenderer = rowItemsRenderer;
exports.rowLayerRenderer = rowLayerRenderer;
exports.getNearestRowObject = getNearestRowObject;
exports.getRowObjectRowNumber = getRowObjectRowNumber;
exports.getVerticalMarginBorder = getVerticalMarginBorder;
exports.getTrueBottom = getTrueBottom;
exports.getNearestRowNumber = getNearestRowNumber;
exports.getMaxOverlappingItems = getMaxOverlappingItems;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Render all items in a row
 * @external {moment} http://momentjs.com/
 * @param  {Object[]} items List of items to render for this row
 * @param  {moment} vis_start The visible start of the timeline
 * @param  {moment} vis_end The visible end of the timeline
 * @param  {number} total_width pixel width of the timeline
 */
function rowItemsRenderer(items, vis_start, vis_end, total_width, itemHeight, itemRenderer) {
  var selectedItems = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];

  var start_end_min = vis_end.diff(vis_start, 'minutes');
  var pixels_per_min = total_width / start_end_min;
  var filtered_items = _lodash2.default.sortBy(_lodash2.default.filter(items, function (i) {
    // if end not before window && start not after window
    return !i.end.isBefore(vis_start) && !i.start.isAfter(vis_end);
  }), function (i) {
    return -i.start.unix();
  }); // sorted in reverse order as we iterate over the array backwards
  var displayItems = [];
  var rowOffset = 0;
  while (filtered_items.length > 0) {
    var lastEnd = null;
    for (var i = filtered_items.length - 1; i >= 0; i--) {
      if (lastEnd === null || filtered_items[i].start >= lastEnd) {
        var item = _lodash2.default.clone(filtered_items[i]);
        item.rowOffset = rowOffset;
        displayItems.push(item);
        filtered_items.splice(i, 1);
        lastEnd = item.end;
      }
    }
    rowOffset++;
  }
  return _lodash2.default.map(displayItems, function (i) {
    var color = i.color;

    var Comp = itemRenderer;
    var top = itemHeight * i['rowOffset'];
    var item_offset_mins = i.start.diff(vis_start, 'minutes');
    var item_duration_mins = i.end.diff(i.start, 'minutes');
    var left = Math.round(item_offset_mins * pixels_per_min);
    var width = Math.round(item_duration_mins * pixels_per_min);
    var compClassnames = 'rct9k-items-inner';
    var outerClassnames = 'rct9k-items-outer item_draggable';
    var style = { backgroundColor: color };
    var isSelected = selectedItems.indexOf(Number(i.key)) > -1;

    if (isSelected) {
      compClassnames += ' rct9k-items-selected';
      outerClassnames += ' rct9k-items-outer-selected';
      style = {};
    }

    return _react2.default.createElement(
      'span',
      {
        key: i.key,
        'data-item-index': i.key,
        className: outerClassnames,
        style: { left: left, width: width, top: top, backgroundColor: 'transparent' } },
      _react2.default.createElement(Comp, { key: i.key, item: i, className: compClassnames, style: style })
    );
  });
}

/**
 * Render row layers
 * @param  {Object[]} layers List of layers to render for this row
 * @param  {moment} vis_start The visible start of the timeline
 * @param  {moment} vis_end The visible end of the timeline
 * @param  {number} total_width pixel width of the timeline
 * @param  {number} itemHeight The layer height in px
 */
function rowLayerRenderer(layers, vis_start, vis_end, total_width, itemHeight) {
  var start_end_min = vis_end.diff(vis_start, 'minutes');
  var pixels_per_min = total_width / start_end_min;
  var filtered_items = _lodash2.default.sortBy(_lodash2.default.filter(layers, function (i) {
    return !i.end.isBefore(vis_start) && !i.start.isAfter(vis_end);
  }), function (i) {
    return -i.start.unix();
  }); // sorted in reverse order as we iterate over the array backwards
  var displayItems = [];
  var rowOffset = 0;
  while (filtered_items.length > 0) {
    var lastEnd = null;
    for (var i = filtered_items.length - 1; i >= 0; i--) {
      if (lastEnd === null || filtered_items[i].start >= lastEnd) {
        var item = _lodash2.default.clone(filtered_items[i]);
        item.rowOffset = rowOffset;
        displayItems.push(item);
        filtered_items.splice(i, 1);
        lastEnd = item.end;
      }
    }
    rowOffset++;
  }
  return _lodash2.default.map(displayItems, function (i) {
    var style = i.style,
        rowNumber = i.rowNumber;

    var top = itemHeight * i['rowOffset'];
    var item_offset_mins = i.start.diff(vis_start, 'minutes');
    var item_duration_mins = i.end.diff(i.start, 'minutes');
    var left = Math.round(item_offset_mins * pixels_per_min);
    var width = Math.round(item_duration_mins * pixels_per_min);
    var height = itemHeight - (rowNumber === 0 ? 2 : 1); // for border
    var outerClassnames = 'rct9k-row-layer';

    return _react2.default.createElement('div', {
      key: 'r-' + rowNumber + '-' + i.start.unix(),
      'data-item-index': i.key,
      className: outerClassnames,
      style: _extends({}, style, { left: left, width: width, top: top, height: height })
    });
  });
}

/**
 * Gets the row object for a given x and y pixel location
 * @param  {number} x The x coordinate of the pixel location
 * @param  {number} y The y coordinate of the pixel location
 * @param  {Object} topDiv Div to search under
 * @returns {Object} The row object at that coordinate
 */
function getNearestRowObject(x, y) {
  var topDiv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;

  var elementsAtPixel = document.elementsFromPoint(x, y);
  return _lodash2.default.find(elementsAtPixel, function (e) {
    var inDiv = topDiv.contains(e);
    return inDiv && e.hasAttribute('data-row-index');
  });
}

/**
 * Gets the row number for a given row object
 * @param  {Object} elem The row object
 * @returns {number} The row number
 */
function getRowObjectRowNumber(elem) {
  return Number(elem ? elem.getAttribute('data-row-index') : 0);
}

/**
 * Gets the vertical margins and borders given an object
 * @param  {Object} elem The row object
 * @returns {number} the pixel position of the bottom of the element
 */
function getVerticalMarginBorder(elem) {
  var computedStyles = window.getComputedStyle(elem);
  // top margin plus bottom margin halved
  var rowMargins = (Math.ceil(parseFloat(computedStyles['marginTop']) + parseFloat(computedStyles['marginBottom'])) || 1) / 2;
  // half the size of the border seems important
  var rowBorders = (Math.ceil(parseFloat(computedStyles['borderTopWidth']) + parseFloat(computedStyles['borderBottomWidth'])) || 1) / 2;
  return Number(rowMargins + rowBorders);
}

/**
 * Gets the true bottom location given an object
 * @param  {Object} elem an element
 * @returns {number} the pixel position of the bottom of the element
 */
function getTrueBottom(elem) {
  /*
  @bendog: leaving this here as a helper, if there's ever a bug around inner items size
  // get object shape
  const rects = elem.getClientRects();
  const bottom = Math.max(Object.values(rects).map(o => o.bottom), 0);
   */
  // calculate the true bottom
  var bound = elem.getBoundingClientRect();
  var bottom = Math.floor(bound.top + bound.height);
  return Number(bottom);
}

/**
 * Gets the row number for a given x and y pixel location
 * @param  {number} x The x coordinate of the pixel location
 * @param  {number} y The y coordinate of the pixel location
 * @param  {Object} topDiv Div to search under
 * @returns {number} The row number
 */
function getNearestRowNumber(x, y) {
  var topDiv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;

  var elementsAtPixel = document.elementsFromPoint(x, y);
  var targetRow = _lodash2.default.find(elementsAtPixel, function (e) {
    var inDiv = topDiv.contains(e);
    return inDiv && e.hasAttribute('data-row-index');
  });
  return targetRow ? targetRow.getAttribute('data-row-index') : 0;
}

/**
 * Use to find the height of a row, given a set of items
 * @param  {Object[]} items List of items
 * @returns {number} Max row height
 */
function getMaxOverlappingItems(items) {
  var max = 0;
  var sorted_items = _lodash2.default.sortBy(items, function (i) {
    return -i.start.unix();
  });

  while (sorted_items.length > 0) {
    var lastEnd = null;
    for (var i = sorted_items.length - 1; i >= 0; i--) {
      if (lastEnd === null || sorted_items[i].start >= lastEnd) {
        lastEnd = sorted_items[i].end;
        sorted_items.splice(i, 1);
      }
    }
    max++;
  }
  return Math.max(max, 1);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9pdGVtVXRpbHMuanMiXSwibmFtZXMiOlsicm93SXRlbXNSZW5kZXJlciIsInJvd0xheWVyUmVuZGVyZXIiLCJnZXROZWFyZXN0Um93T2JqZWN0IiwiZ2V0Um93T2JqZWN0Um93TnVtYmVyIiwiZ2V0VmVydGljYWxNYXJnaW5Cb3JkZXIiLCJnZXRUcnVlQm90dG9tIiwiZ2V0TmVhcmVzdFJvd051bWJlciIsImdldE1heE92ZXJsYXBwaW5nSXRlbXMiLCJpdGVtcyIsInZpc19zdGFydCIsInZpc19lbmQiLCJ0b3RhbF93aWR0aCIsIml0ZW1IZWlnaHQiLCJpdGVtUmVuZGVyZXIiLCJzZWxlY3RlZEl0ZW1zIiwic3RhcnRfZW5kX21pbiIsImRpZmYiLCJwaXhlbHNfcGVyX21pbiIsImZpbHRlcmVkX2l0ZW1zIiwiXyIsInNvcnRCeSIsImZpbHRlciIsImkiLCJlbmQiLCJpc0JlZm9yZSIsInN0YXJ0IiwiaXNBZnRlciIsInVuaXgiLCJkaXNwbGF5SXRlbXMiLCJyb3dPZmZzZXQiLCJsZW5ndGgiLCJsYXN0RW5kIiwiaXRlbSIsImNsb25lIiwicHVzaCIsInNwbGljZSIsIm1hcCIsImNvbG9yIiwiQ29tcCIsInRvcCIsIml0ZW1fb2Zmc2V0X21pbnMiLCJpdGVtX2R1cmF0aW9uX21pbnMiLCJsZWZ0IiwiTWF0aCIsInJvdW5kIiwid2lkdGgiLCJjb21wQ2xhc3NuYW1lcyIsIm91dGVyQ2xhc3NuYW1lcyIsInN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiaXNTZWxlY3RlZCIsImluZGV4T2YiLCJOdW1iZXIiLCJrZXkiLCJsYXllcnMiLCJyb3dOdW1iZXIiLCJoZWlnaHQiLCJ4IiwieSIsInRvcERpdiIsImRvY3VtZW50IiwiZWxlbWVudHNBdFBpeGVsIiwiZWxlbWVudHNGcm9tUG9pbnQiLCJmaW5kIiwiaW5EaXYiLCJjb250YWlucyIsImUiLCJoYXNBdHRyaWJ1dGUiLCJlbGVtIiwiZ2V0QXR0cmlidXRlIiwiY29tcHV0ZWRTdHlsZXMiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwicm93TWFyZ2lucyIsImNlaWwiLCJwYXJzZUZsb2F0Iiwicm93Qm9yZGVycyIsImJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYm90dG9tIiwiZmxvb3IiLCJ0YXJnZXRSb3ciLCJtYXgiLCJzb3J0ZWRfaXRlbXMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztRQWNnQkEsZ0IsR0FBQUEsZ0I7UUFnRUFDLGdCLEdBQUFBLGdCO1FBb0RBQyxtQixHQUFBQSxtQjtRQWFBQyxxQixHQUFBQSxxQjtRQVNBQyx1QixHQUFBQSx1QjtRQWlCQUMsYSxHQUFBQSxhO1FBb0JBQyxtQixHQUFBQSxtQjtRQWNBQyxzQixHQUFBQSxzQjs7QUF6TWhCOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7Ozs7Ozs7O0FBUU8sU0FBU1AsZ0JBQVQsQ0FBMEJRLEtBQTFCLEVBQWlDQyxTQUFqQyxFQUE0Q0MsT0FBNUMsRUFBcURDLFdBQXJELEVBQWtFQyxVQUFsRSxFQUE4RUMsWUFBOUUsRUFBZ0g7QUFBQSxNQUFwQkMsYUFBb0IsdUVBQUosRUFBSTs7QUFDckgsTUFBTUMsZ0JBQWdCTCxRQUFRTSxJQUFSLENBQWFQLFNBQWIsRUFBd0IsU0FBeEIsQ0FBdEI7QUFDQSxNQUFNUSxpQkFBaUJOLGNBQWNJLGFBQXJDO0FBQ0EsTUFBSUcsaUJBQWlCQyxpQkFBRUMsTUFBRixDQUNuQkQsaUJBQUVFLE1BQUYsQ0FBU2IsS0FBVCxFQUFnQixhQUFLO0FBQ25CO0FBQ0EsV0FBTyxDQUFDYyxFQUFFQyxHQUFGLENBQU1DLFFBQU4sQ0FBZWYsU0FBZixDQUFELElBQThCLENBQUNhLEVBQUVHLEtBQUYsQ0FBUUMsT0FBUixDQUFnQmhCLE9BQWhCLENBQXRDO0FBQ0QsR0FIRCxDQURtQixFQUtuQjtBQUFBLFdBQUssQ0FBQ1ksRUFBRUcsS0FBRixDQUFRRSxJQUFSLEVBQU47QUFBQSxHQUxtQixDQUFyQixDQUhxSCxDQVNsSDtBQUNILE1BQUlDLGVBQWUsRUFBbkI7QUFD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Q0Q7O0FBRUQ7Ozs7O0FBS08sU0FBUzlELHNCQUFULENBQWdDQyxLQUFoQyxFQUF1QztBQUM1QyxNQUFJMEUsTUFBTSxDQUFWO0FBQ0EsTUFBSUMsZUFBZWhFLGlCQUFFQyxNQUFGLENBQVNaLEtBQVQsRUFBZ0I7QUFBQSxXQUFLLENBQUNjLEVBQUVHLEtBQUYsQ0FBUUUsSUFBUixFQUFOO0FBQUEsR0FBaEIsQ0FBbkI7O0FBRUEsU0FBT3dELGFBQWFyRCxNQUFiLEdBQXNCLENBQTdCLEVBQWdDO0FBQzlCLFFBQUlDLFVBQVUsSUFBZDtBQUNBLFNBQUssSUFBSVQsSUFBSTZELGFBQWFyRCxNQUFiLEdBQXNCLENBQW5DLEVBQXNDUixLQUFLLENBQTNDLEVBQThDQSxHQUE5QyxFQUFtRDtBQUNqRCxVQUFJUyxZQUFZLElBQVosSUFBb0JvRCxhQUFhN0QsQ0FBYixFQUFnQkcsS0FBaEIsSUFBeUJNLE9BQWpELEVBQTBEO0FBQ3hEQSxrQkFBVW9ELGFBQWE3RCxDQUFiLEVBQWdCQyxHQUExQjtBQUNBNEQscUJBQWFoRCxNQUFiLENBQW9CYixDQUFwQixFQUF1QixDQUF2QjtBQUNEO0FBQ0Y7QUFDRDREO0FBQ0Q7QUFDRCxTQUFPdkMsS0FBS3VDLEdBQUwsQ0FBU0EsR0FBVCxFQUFjLENBQWQsQ0FBUDtBQUNEIiwiZmlsZSI6Iml0ZW1VdGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXIgYWxsIGl0ZW1zIGluIGEgcm93XHJcbiAqIEBleHRlcm5hbCB7bW9tZW50fSBodHRwOi8vbW9tZW50anMuY29tL1xyXG4gKiBAcGFyYW0gIHtPYmplY3RbXX0gaXRlbXMgTGlzdCBvZiBpdGVtcyB0byByZW5kZXIgZm9yIHRoaXMgcm93XHJcbiAqIEBwYXJhbSAge21vbWVudH0gdmlzX3N0YXJ0IFRoZSB2aXNpYmxlIHN0YXJ0IG9mIHRoZSB0aW1lbGluZVxyXG4gKiBAcGFyYW0gIHttb21lbnR9IHZpc19lbmQgVGhlIHZpc2libGUgZW5kIG9mIHRoZSB0aW1lbGluZVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRvdGFsX3dpZHRoIHBpeGVsIHdpZHRoIG9mIHRoZSB0aW1lbGluZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvd0l0ZW1zUmVuZGVyZXIoaXRlbXMsIHZpc19zdGFydCwgdmlzX2VuZCwgdG90YWxfd2lkdGgsIGl0ZW1IZWlnaHQsIGl0ZW1SZW5kZXJlciwgc2VsZWN0ZWRJdGVtcyA9IFtdKSB7XHJcbiAgY29uc3Qgc3RhcnRfZW5kX21pbiA9IHZpc19lbmQuZGlmZih2aXNfc3RhcnQsICdtaW51dGVzJyk7XHJcbiAgY29uc3QgcGl4ZWxzX3Blcl9taW4gPSB0b3RhbF93aWR0aCAvIHN0YXJ0X2VuZF9taW47XHJcbiAgbGV0IGZpbHRlcmVkX2l0ZW1zID0gXy5zb3J0QnkoXHJcbiAgICBfLmZpbHRlcihpdGVtcywgaSA9PiB7XHJcbiAgICAgIC8vIGlmIGVuZCBub3QgYmVmb3JlIHdpbmRvdyAmJiBzdGFydCBub3QgYWZ0ZXIgd2luZG93XHJcbiAgICAgIHJldHVybiAhaS5lbmQuaXNCZWZvcmUodmlzX3N0YXJ0KSAmJiAhaS5zdGFydC5pc0FmdGVyKHZpc19lbmQpO1xyXG4gICAgfSksXHJcbiAgICBpID0+IC1pLnN0YXJ0LnVuaXgoKVxyXG4gICk7IC8vIHNvcnRlZCBpbiByZXZlcnNlIG9yZGVyIGFzIHdlIGl0ZXJhdGUgb3ZlciB0aGUgYXJyYXkgYmFja3dhcmRzXHJcbiAgbGV0IGRpc3BsYXlJdGVtcyA9IFtdO1xyXG4gIGxldCByb3dPZmZzZXQgPSAwO1xyXG4gIHdoaWxlIChmaWx0ZXJlZF9pdGVtcy5sZW5ndGggPiAwKSB7XHJcbiAgICBsZXQgbGFzdEVuZCA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gZmlsdGVyZWRfaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgaWYgKGxhc3RFbmQgPT09IG51bGwgfHwgZmlsdGVyZWRfaXRlbXNbaV0uc3RhcnQgPj0gbGFzdEVuZCkge1xyXG4gICAgICAgIGxldCBpdGVtID0gXy5jbG9uZShmaWx0ZXJlZF9pdGVtc1tpXSk7XHJcbiAgICAgICAgaXRlbS5yb3dPZmZzZXQgPSByb3dPZmZzZXQ7XHJcbiAgICAgICAgZGlzcGxheUl0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICAgICAgZmlsdGVyZWRfaXRlbXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIGxhc3RFbmQgPSBpdGVtLmVuZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcm93T2Zmc2V0Kys7XHJcbiAgfVxyXG4gIHJldHVybiBfLm1hcChkaXNwbGF5SXRlbXMsIGkgPT4ge1xyXG4gICAgY29uc3Qge2NvbG9yfSA9IGk7XHJcbiAgICBjb25zdCBDb21wID0gaXRlbVJlbmRlcmVyO1xyXG4gICAgbGV0IHRvcCA9IGl0ZW1IZWlnaHQgKiBpWydyb3dPZmZzZXQnXTtcclxuICAgIGxldCBpdGVtX29mZnNldF9taW5zID0gaS5zdGFydC5kaWZmKHZpc19zdGFydCwgJ21pbnV0ZXMnKTtcclxuICAgIGxldCBpdGVtX2R1cmF0aW9uX21pbnMgPSBpLmVuZC5kaWZmKGkuc3RhcnQsICdtaW51dGVzJyk7XHJcbiAgICBsZXQgbGVmdCA9IE1hdGgucm91bmQoaXRlbV9vZmZzZXRfbWlucyAqIHBpeGVsc19wZXJfbWluKTtcclxuICAgIGxldCB3aWR0aCA9IE1hdGgucm91bmQoaXRlbV9kdXJhdGlvbl9taW5zICogcGl4ZWxzX3Blcl9taW4pO1xyXG4gICAgbGV0IGNvbXBDbGFzc25hbWVzID0gJ3JjdDlrLWl0ZW1zLWlubmVyJztcclxuICAgIGxldCBvdXRlckNsYXNzbmFtZXMgPSAncmN0OWstaXRlbXMtb3V0ZXIgaXRlbV9kcmFnZ2FibGUnO1xyXG4gICAgbGV0IHN0eWxlID0ge2JhY2tncm91bmRDb2xvcjogY29sb3J9O1xyXG4gICAgbGV0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZEl0ZW1zLmluZGV4T2YoTnVtYmVyKGkua2V5KSkgPiAtMTtcclxuXHJcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xyXG4gICAgICBjb21wQ2xhc3NuYW1lcyArPSAnIHJjdDlrLWl0ZW1zLXNlbGVjdGVkJztcclxuICAgICAgb3V0ZXJDbGFzc25hbWVzICs9ICcgcmN0OWstaXRlbXMtb3V0ZXItc2VsZWN0ZWQnO1xyXG4gICAgICBzdHlsZSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxzcGFuXHJcbiAgICAgICAga2V5PXtpLmtleX1cclxuICAgICAgICBkYXRhLWl0ZW0taW5kZXg9e2kua2V5fVxyXG4gICAgICAgIGNsYXNzTmFtZT17b3V0ZXJDbGFzc25hbWVzfVxyXG4gICAgICAgIHN0eWxlPXt7bGVmdCwgd2lkdGgsIHRvcCwgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnfX0+XHJcbiAgICAgICAgPENvbXAga2V5PXtpLmtleX0gaXRlbT17aX0gY2xhc3NOYW1lPXtjb21wQ2xhc3NuYW1lc30gc3R5bGU9e3N0eWxlfSAvPlxyXG4gICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmVuZGVyIHJvdyBsYXllcnNcclxuICogQHBhcmFtICB7T2JqZWN0W119IGxheWVycyBMaXN0IG9mIGxheWVycyB0byByZW5kZXIgZm9yIHRoaXMgcm93XHJcbiAqIEBwYXJhbSAge21vbWVudH0gdmlzX3N0YXJ0IFRoZSB2aXNpYmxlIHN0YXJ0IG9mIHRoZSB0aW1lbGluZVxyXG4gKiBAcGFyYW0gIHttb21lbnR9IHZpc19lbmQgVGhlIHZpc2libGUgZW5kIG9mIHRoZSB0aW1lbGluZVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRvdGFsX3dpZHRoIHBpeGVsIHdpZHRoIG9mIHRoZSB0aW1lbGluZVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGl0ZW1IZWlnaHQgVGhlIGxheWVyIGhlaWdodCBpbiBweFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvd0xheWVyUmVuZGVyZXIobGF5ZXJzLCB2aXNfc3RhcnQsIHZpc19lbmQsIHRvdGFsX3dpZHRoLCBpdGVtSGVpZ2h0KSB7XHJcbiAgY29uc3Qgc3RhcnRfZW5kX21pbiA9IHZpc19lbmQuZGlmZih2aXNfc3RhcnQsICdtaW51dGVzJyk7XHJcbiAgY29uc3QgcGl4ZWxzX3Blcl9taW4gPSB0b3RhbF93aWR0aCAvIHN0YXJ0X2VuZF9taW47XHJcbiAgbGV0IGZpbHRlcmVkX2l0ZW1zID0gXy5zb3J0QnkoXHJcbiAgICBfLmZpbHRlcihsYXllcnMsIGkgPT4ge1xyXG4gICAgICByZXR1cm4gIWkuZW5kLmlzQmVmb3JlKHZpc19zdGFydCkgJiYgIWkuc3RhcnQuaXNBZnRlcih2aXNfZW5kKTtcclxuICAgIH0pLFxyXG4gICAgaSA9PiAtaS5zdGFydC51bml4KClcclxuICApOyAvLyBzb3J0ZWQgaW4gcmV2ZXJzZSBvcmRlciBhcyB3ZSBpdGVyYXRlIG92ZXIgdGhlIGFycmF5IGJhY2t3YXJkc1xyXG4gIGxldCBkaXNwbGF5SXRlbXMgPSBbXTtcclxuICBsZXQgcm93T2Zmc2V0ID0gMDtcclxuICB3aGlsZSAoZmlsdGVyZWRfaXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgbGV0IGxhc3RFbmQgPSBudWxsO1xyXG4gICAgZm9yIChsZXQgaSA9IGZpbHRlcmVkX2l0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGlmIChsYXN0RW5kID09PSBudWxsIHx8IGZpbHRlcmVkX2l0ZW1zW2ldLnN0YXJ0ID49IGxhc3RFbmQpIHtcclxuICAgICAgICBsZXQgaXRlbSA9IF8uY2xvbmUoZmlsdGVyZWRfaXRlbXNbaV0pO1xyXG4gICAgICAgIGl0ZW0ucm93T2Zmc2V0ID0gcm93T2Zmc2V0O1xyXG4gICAgICAgIGRpc3BsYXlJdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIGZpbHRlcmVkX2l0ZW1zLnNwbGljZShpLCAxKTtcclxuICAgICAgICBsYXN0RW5kID0gaXRlbS5lbmQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJvd09mZnNldCsrO1xyXG4gIH1cclxuICByZXR1cm4gXy5tYXAoZGlzcGxheUl0ZW1zLCBpID0+IHtcclxuICAgIGNvbnN0IHtzdHlsZSwgcm93TnVtYmVyfSA9IGk7XHJcbiAgICBsZXQgdG9wID0gaXRlbUhlaWdodCAqIGlbJ3Jvd09mZnNldCddO1xyXG4gICAgbGV0IGl0ZW1fb2Zmc2V0X21pbnMgPSBpLnN0YXJ0LmRpZmYodmlzX3N0YXJ0LCAnbWludXRlcycpO1xyXG4gICAgbGV0IGl0ZW1fZHVyYXRpb25fbWlucyA9IGkuZW5kLmRpZmYoaS5zdGFydCwgJ21pbnV0ZXMnKTtcclxuICAgIGxldCBsZWZ0ID0gTWF0aC5yb3VuZChpdGVtX29mZnNldF9taW5zICogcGl4ZWxzX3Blcl9taW4pO1xyXG4gICAgbGV0IHdpZHRoID0gTWF0aC5yb3VuZChpdGVtX2R1cmF0aW9uX21pbnMgKiBwaXhlbHNfcGVyX21pbik7XHJcbiAgICBsZXQgaGVpZ2h0ID0gaXRlbUhlaWdodCAtIChyb3dOdW1iZXIgPT09IDAgPyAyIDogMSk7IC8vIGZvciBib3JkZXJcclxuICAgIGxldCBvdXRlckNsYXNzbmFtZXMgPSAncmN0OWstcm93LWxheWVyJztcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAga2V5PXtgci0ke3Jvd051bWJlcn0tJHtpLnN0YXJ0LnVuaXgoKX1gfVxyXG4gICAgICAgIGRhdGEtaXRlbS1pbmRleD17aS5rZXl9XHJcbiAgICAgICAgY2xhc3NOYW1lPXtvdXRlckNsYXNzbmFtZXN9XHJcbiAgICAgICAgc3R5bGU9e3suLi5zdHlsZSwgbGVmdCwgd2lkdGgsIHRvcCwgaGVpZ2h0fX1cclxuICAgICAgLz5cclxuICAgICk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSByb3cgb2JqZWN0IGZvciBhIGdpdmVuIHggYW5kIHkgcGl4ZWwgbG9jYXRpb25cclxuICogQHBhcmFtICB7bnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBpeGVsIGxvY2F0aW9uXHJcbiAqIEBwYXJhbSAge251bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSBwaXhlbCBsb2NhdGlvblxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRvcERpdiBEaXYgdG8gc2VhcmNoIHVuZGVyXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByb3cgb2JqZWN0IGF0IHRoYXQgY29vcmRpbmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE5lYXJlc3RSb3dPYmplY3QoeCwgeSwgdG9wRGl2ID0gZG9jdW1lbnQpIHtcclxuICBsZXQgZWxlbWVudHNBdFBpeGVsID0gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoeCwgeSk7XHJcbiAgcmV0dXJuIF8uZmluZChlbGVtZW50c0F0UGl4ZWwsIGUgPT4ge1xyXG4gICAgY29uc3QgaW5EaXYgPSB0b3BEaXYuY29udGFpbnMoZSk7XHJcbiAgICByZXR1cm4gaW5EaXYgJiYgZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtcm93LWluZGV4Jyk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSByb3cgbnVtYmVyIGZvciBhIGdpdmVuIHJvdyBvYmplY3RcclxuICogQHBhcmFtICB7T2JqZWN0fSBlbGVtIFRoZSByb3cgb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgbnVtYmVyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um93T2JqZWN0Um93TnVtYmVyKGVsZW0pIHtcclxuICByZXR1cm4gTnVtYmVyKGVsZW0gPyBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1yb3ctaW5kZXgnKSA6IDApO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgdmVydGljYWwgbWFyZ2lucyBhbmQgYm9yZGVycyBnaXZlbiBhbiBvYmplY3RcclxuICogQHBhcmFtICB7T2JqZWN0fSBlbGVtIFRoZSByb3cgb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgYm90dG9tIG9mIHRoZSBlbGVtZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVydGljYWxNYXJnaW5Cb3JkZXIoZWxlbSkge1xyXG4gIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XHJcbiAgLy8gdG9wIG1hcmdpbiBwbHVzIGJvdHRvbSBtYXJnaW4gaGFsdmVkXHJcbiAgY29uc3Qgcm93TWFyZ2lucyA9XHJcbiAgICAoTWF0aC5jZWlsKHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZXNbJ21hcmdpblRvcCddKSArIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZXNbJ21hcmdpbkJvdHRvbSddKSkgfHwgMSkgLyAyO1xyXG4gIC8vIGhhbGYgdGhlIHNpemUgb2YgdGhlIGJvcmRlciBzZWVtcyBpbXBvcnRhbnRcclxuICBjb25zdCByb3dCb3JkZXJzID1cclxuICAgIChNYXRoLmNlaWwocGFyc2VGbG9hdChjb21wdXRlZFN0eWxlc1snYm9yZGVyVG9wV2lkdGgnXSkgKyBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVzWydib3JkZXJCb3R0b21XaWR0aCddKSkgfHwgMSkgL1xyXG4gICAgMjtcclxuICByZXR1cm4gTnVtYmVyKHJvd01hcmdpbnMgKyByb3dCb3JkZXJzKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHRydWUgYm90dG9tIGxvY2F0aW9uIGdpdmVuIGFuIG9iamVjdFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVsZW0gYW4gZWxlbWVudFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRydWVCb3R0b20oZWxlbSkge1xyXG4gIC8qXHJcbiAgQGJlbmRvZzogbGVhdmluZyB0aGlzIGhlcmUgYXMgYSBoZWxwZXIsIGlmIHRoZXJlJ3MgZXZlciBhIGJ1ZyBhcm91bmQgaW5uZXIgaXRlbXMgc2l6ZVxyXG4gIC8vIGdldCBvYmplY3Qgc2hhcGVcclxuICBjb25zdCByZWN0cyA9IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKTtcclxuICBjb25zdCBib3R0b20gPSBNYXRoLm1heChPYmplY3QudmFsdWVzKHJlY3RzKS5tYXAobyA9PiBvLmJvdHRvbSksIDApO1xyXG4gICAqL1xyXG4gIC8vIGNhbGN1bGF0ZSB0aGUgdHJ1ZSBib3R0b21cclxuICBjb25zdCBib3VuZCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgY29uc3QgYm90dG9tID0gTWF0aC5mbG9vcihib3VuZC50b3AgKyBib3VuZC5oZWlnaHQpO1xyXG4gIHJldHVybiBOdW1iZXIoYm90dG9tKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHJvdyBudW1iZXIgZm9yIGEgZ2l2ZW4geCBhbmQgeSBwaXhlbCBsb2NhdGlvblxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcGl4ZWwgbG9jYXRpb25cclxuICogQHBhcmFtICB7bnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBpeGVsIGxvY2F0aW9uXHJcbiAqIEBwYXJhbSAge09iamVjdH0gdG9wRGl2IERpdiB0byBzZWFyY2ggdW5kZXJcclxuICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyBudW1iZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXROZWFyZXN0Um93TnVtYmVyKHgsIHksIHRvcERpdiA9IGRvY3VtZW50KSB7XHJcbiAgbGV0IGVsZW1lbnRzQXRQaXhlbCA9IGRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KHgsIHkpO1xyXG4gIGxldCB0YXJnZXRSb3cgPSBfLmZpbmQoZWxlbWVudHNBdFBpeGVsLCBlID0+IHtcclxuICAgIGNvbnN0IGluRGl2ID0gdG9wRGl2LmNvbnRhaW5zKGUpO1xyXG4gICAgcmV0dXJuIGluRGl2ICYmIGUuaGFzQXR0cmlidXRlKCdkYXRhLXJvdy1pbmRleCcpO1xyXG4gIH0pO1xyXG4gIHJldHVybiB0YXJnZXRSb3cgPyB0YXJnZXRSb3cuZ2V0QXR0cmlidXRlKCdkYXRhLXJvdy1pbmRleCcpIDogMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZSB0byBmaW5kIHRoZSBoZWlnaHQgb2YgYSByb3csIGdpdmVuIGEgc2V0IG9mIGl0ZW1zXHJcbiAqIEBwYXJhbSAge09iamVjdFtdfSBpdGVtcyBMaXN0IG9mIGl0ZW1zXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE1heCByb3cgaGVpZ2h0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4T3ZlcmxhcHBpbmdJdGVtcyhpdGVtcykge1xyXG4gIGxldCBtYXggPSAwO1xyXG4gIGxldCBzb3J0ZWRfaXRlbXMgPSBfLnNvcnRCeShpdGVtcywgaSA9PiAtaS5zdGFydC51bml4KCkpO1xyXG5cclxuICB3aGlsZSAoc29ydGVkX2l0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgIGxldCBsYXN0RW5kID0gbnVsbDtcclxuICAgIGZvciAobGV0IGkgPSBzb3J0ZWRfaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgaWYgKGxhc3RFbmQgPT09IG51bGwgfHwgc29ydGVkX2l0ZW1zW2ldLnN0YXJ0ID49IGxhc3RFbmQpIHtcclxuICAgICAgICBsYXN0RW5kID0gc29ydGVkX2l0ZW1zW2ldLmVuZDtcclxuICAgICAgICBzb3J0ZWRfaXRlbXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXgrKztcclxuICB9XHJcbiAgcmV0dXJuIE1hdGgubWF4KG1heCwgMSk7XHJcbn1cclxuIl19